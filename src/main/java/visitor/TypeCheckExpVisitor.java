package visitor;import syntaxtree.*;import symboltable.*;import visitor.error.ErrorMsg;public class TypeCheckExpVisitor extends TypeDepthFirstVisitor{    private ErrorMsg error;    private Table symbolTable;    protected RamClass currClass;    protected RamMethod currMethod;    public TypeCheckExpVisitor(ErrorMsg error, Table symbolTable)    {        this.error = error;        this.symbolTable = symbolTable;    }    // Exp e1,e2;    public Type visit(Or n)    {        if (!(n.e1.accept(this) instanceof BooleanType))        {            error.complain("Left side of Or must be of type bool");        }        if (!(n.e2.accept(this) instanceof BooleanType))        {            error.complain("Right side of Or must be of type bool");        }        return new BooleanType();    }    // Exp e1,e2;    public Type visit(And n)    {        if (!(n.e1.accept(this) instanceof BooleanType))        {            error.complain("Left side of And must be of type bool");        }        if (!(n.e2.accept(this) instanceof BooleanType))        {            error.complain("Right side of And must be of type bool");        }        return new BooleanType();    }    // Exp e1,e2;    public Type visit(LessThanOrEqual n)    {        if (!(n.e1.accept(this) instanceof IntegerType))        {            error.complain("Left side of LessThanOrEqual must be of type integer");        }        if (!(n.e2.accept(this) instanceof IntegerType))        {            error.complain("Right side of LessThanOrEqual must be of type integer");        }        return new BooleanType();    }    // Exp e1,e2;    public Type visit(LessThan n)    {        if (!(n.e1.accept(this) instanceof IntegerType))        {            error.complain("Left side of LessThan must be of type integer");        }        if (!(n.e2.accept(this) instanceof IntegerType))        {            error.complain("Right side of LessThan must be of type integer");        }        return new BooleanType();    }    public Type visit(Equality n)    {        if (!(((n.e1.accept(this) instanceof IntegerType) && (n.e2.accept(this) instanceof IntegerType)) || ((n.e1                .accept(this) instanceof BooleanType) && (n.e2.accept(this) instanceof BooleanType))))        {            error.complain("Left and right side of equality must both be of either type integer or type bool");        }        return new BooleanType();    }    // Exp e1,e2;    public Type visit(Plus n)    {        if (!(n.e1.accept(this) instanceof IntegerType))        {            error.complain("Left side of LessThan must be of type integer");        }        if (!(n.e2.accept(this) instanceof IntegerType))        {            error.complain("Right side of LessThan must be of type integer");        }        return new IntegerType();    }    // Exp e1,e2;    public Type visit(PlusEquals n)    {        if (!(n.id.accept(this) instanceof IntegerType))        {            error.complain("Left side of PlusEquals must be of type integer");        }        if (!(n.e.accept(this) instanceof IntegerType))        {            error.complain("Right side of PlusEquals must be of type integer");        }        return new IntegerType();    }    // Exp e1,e2;    public Type visit(Minus n)    {        if (!(n.e1.accept(this) instanceof IntegerType))        {            error.complain("Left side of LessThan must be of type integer");        }        if (!(n.e2.accept(this) instanceof IntegerType))        {            error.complain("Right side of LessThan must be of type integer");        }        return new IntegerType();    }    // Exp e1,e2;    public Type visit(Times n)    {        if (!(n.e1.accept(this) instanceof IntegerType))        {            error.complain("Left side of LessThan must be of type integer");        }        if (!(n.e2.accept(this) instanceof IntegerType))        {            error.complain("Right side of LessThan must be of type integer");        }        return new IntegerType();    }    // Exp e1,e2;    public Type visit(ArrayLookup n)    {        if (!(n.e1.accept(this) instanceof IntArrayType))        {            error.complain("Left side of LessThan must be of type integer");        }        if (!(n.e2.accept(this) instanceof IntegerType))        {            error.complain("Right side of LessThan must be of type integer");        }        return new IntegerType();    }    // Exp e;    public Type visit(ArrayLength n)    {        if (!(n.e.accept(this) instanceof IntArrayType))        {            error.complain("Left side of LessThan must be of type integer");        }        return new IntegerType();    }    // Exp e;    // Identifier i;    // ExpList el;    public Type visit(Call n)    {        if (!(n.e.accept(this) instanceof IdentifierType))        {            error.complain("method " + n.i.toString() + "called  on something that is not a"                    + " class or Object.");            return null;        }        String mname = n.i.toString();        String cname = ((IdentifierType) n.e.accept(this)).s;        RamMethod calledMethod = symbolTable.getMethod(mname, cname);        if (n.el.size() != calledMethod.getNumberOfParams())        {            error.complain("Invalid number of parameters passed to " + cname + "." + mname);        }        else        {            for (int i = 0; i < n.el.size(); i++)            {                Type t1 = null;                Type t2 = null;                if (calledMethod.getParamAt(i) != null)                {                    t1 = calledMethod.getParamAt(i).type();                }                t2 = n.el.elementAt(i).accept(this);                if (!symbolTable.compareTypes(t1, t2))                {                    error.complain("Type error in arguments passed to " + cname + "." + mname);                }            }        }        return symbolTable.getMethodType(mname, cname);    }    // int i;    public Type visit(IntegerLiteral n)    {        return new IntegerType();    }    public Type visit(True n)    {        return new BooleanType();    }    public Type visit(False n)    {        return new BooleanType();    }    // String s;    public Type visit(IdentifierExp n)    {        return symbolTable.getVarType(currMethod, currClass, n.s);    }    public Type visit(This n)    {        return currClass.type();    }    // Exp e;    public Type visit(NewArray n)    {        if (!(n.e.accept(this) instanceof IntegerType))        {            error.complain("Left side of LessThan must be of type integer");        }        return new IntArrayType();    }    // Identifier i;    public Type visit(NewObject n)    {        return new IdentifierType(n.i.s);    }    // Exp e;    public Type visit(Not n)    {        if (!(n.e.accept(this) instanceof BooleanType))        {            error.complain("Left side of LessThan must be of type boolean");        }        return new BooleanType();    }}