package syntaxtree.visitor;import symboltable.*;import syntaxtree.*;import visitor.error.ErrorMsg;public class BuildSymbolTableVisitor extends TypeDepthFirstVisitor{    private Table symbolTable;    private RamClass currClass;    private RamMethod currMethod;    private ErrorMsg error = new ErrorMsg();    public BuildSymbolTableVisitor()    {        symbolTable = new Table();         }    public Table getSymTab()    {        return symbolTable;    }        public ErrorMsg getErrorMsg()    {        return error;    }    // MainClass m;    // ClassDeclList cl;    public Type visit(Program n)    {        n.m.accept(this);        for (int i = 0; i < n.cl.size(); i++)        {            n.cl.elementAt(i).accept(this);        }        return null;    }    // Identifier i1,i2;    // Statement s;    public Type visit(MainClass n)    {        symbolTable.addClass(n.i1.toString());        currClass = symbolTable.getClass(n.i1.toString());        // Ugly hack -- creating        // new IdentifierType("void") and new IdentifierType("String[]");        // not worth defining a VoidType and StringAryType        // for just a few occurrences        symbolTable.getClass(n.i1.s).addMethod("main", new IdentifierType("void"));        currMethod = symbolTable.getClass(n.i1.toString()).getMethod("main");        symbolTable.getMethod("main", currClass.getId()).addParam(n.i2.toString(),                new IdentifierType("String[]"));        n.s.accept(this);        currMethod = null;        return null;    }    // Identifier i;    // VarDeclList vl;    // MethodDeclList ml;    public Type visit(ClassDeclSimple n)    {                if (!symbolTable.addClass(n.i.toString()))        {            error.complain("Class " + n.i.toString() + " is already defined");                    }        currClass = symbolTable.getClass(n.i.toString());        for (int i = 0; i < n.vl.size(); i++)        {            n.vl.get(i).accept(this);        }        for (int i = 0; i < n.ml.size(); i++)        {            n.ml.elementAt(i).accept(this);        }        return null;    }    // Type t;    // Identifier i;    public Type visit(VarDecl n)    {        Type t = n.t.accept(this);        String id = n.i.toString();        if (currMethod == null)        {            if (!currClass.addVar(id, t))            {                error.complain(id + " is already defined in " + currClass.getId());                            }        }        else        {            if (!currMethod.addVar(id, t))            {                error.complain(id + " is already defined in " + currClass.getId() + "."                        + currMethod.getId());                            }        }        return null;    }    // Type t;    // Identifier i;    // FormalList fl;    // VarDeclList vl;    // StatementList sl;    // Exp e;    public Type visit(MethodDecl n)    {        Type t = n.t.accept(this);        String id = n.i.toString();        if (!currClass.addMethod(id, t))        {            error.complain("Method " + id + " is already defined in " + currClass.getId());                    }        currMethod = currClass.getMethod(id);        for (int i = 0; i < n.fl.size(); i++)        {            n.fl.get(i).accept(this);        }        for (int i = 0; i < n.vl.size(); i++)        {            n.vl.get(i).accept(this);        }        for (int i = 0; i < n.sl.size(); i++)        {            n.sl.get(i).accept(this);        }        n.e.accept(this);        currMethod = null;        return null;    }    // Type t;    // Identifier i;    public Type visit(Formal n)    {        Type t = n.t.accept(this);        String id = n.i.toString();        if (!currMethod.addParam(id, t) || currClass.containsVar(id))        {            error.complain("Formal " + id + " is already defined in " + currClass.getId() + "."                    + currMethod.getId());                    }        return null;    }    public Type visit(IntArrayType n)    {        return n;    }    public Type visit(BooleanType n)    {        return n;    }    public Type visit(IntegerType n)    {        return n;    }    // String s;    public Type visit(IdentifierType n)    {        return n;    }    // StatementList sl;    public Type visit(Block n)    {        for (int i = 0; i < n.sl.size(); i++)        {            n.sl.get(i).accept(this);        }        return null;    }        public Type visit(ForEach n)    {                if(!currMethod.addVar(n.iterator.s, n.type.accept(this)) || currClass.containsVar(n.iterator.s))                error.complain(n.iterator.s + " is already defined in " + currClass.getId() + "." + currMethod.getId());;        n.statement.accept(this);        return null;    }}