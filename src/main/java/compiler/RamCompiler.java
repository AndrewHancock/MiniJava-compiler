package compiler;import symboltable.Table;import syntaxtree.Program;import visitor.BuildSymbolTableVisitor;import visitor.IrGenerator;import visitor.TypeCheckVisitor;import visitor.Visitor;import frontend.generated.*;import ir.backend.X86CodeGenerator;import ir.cfgraph.Function;import ir.ops.Declaration;import ir.ops.RecordDeclaration;import ir.visitor.IrVisitor;import ir.visitor.StringVisitor;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.io.PrintStream;import java.io.PrintWriter;import java.util.Collection;import org.apache.commons.cli.BasicParser;import org.apache.commons.cli.CommandLine;import org.apache.commons.cli.HelpFormatter;import org.apache.commons.cli.Option;import org.apache.commons.cli.Options;import org.apache.commons.cli.ParseException;public class RamCompiler{	public static Options getCliOptions()	{		Options options = new Options();		options.addOption(new Option("o", "output", true, "output path"));		options.addOption(new Option("i", "input", true, "input path"));		options.addOption(new Option("f", "format", true,				"Output format. Valid options: x86, python, mips"));		options.addOption(new Option("h", "help", false, "print usage"));		return options;	}	public static IrVisitor getVisitorForFormatString(String format, PrintStream ps,			Collection<RecordDeclaration> recordList)	{		format = format.toUpperCase();		if (format.equals("X86"))			return new X86CodeGenerator(ps, recordList);				/*else if (format.equals("PYTHON"))			return new PythonVisitor(ps, symTable);		else if (format.equals("MIPS"))			return new MipsCodeGenerator(ps, symTable);		else*/		throw new IllegalArgumentException(				"Invalid output format specified. Valid options are: x86, python, mips");	}	public static void main(String[] args) throws ParseException, frontend.generated.ParseException, IOException	{		BasicParser parser = new BasicParser();		Options cliOptions = getCliOptions();		CommandLine options = parser.parse(cliOptions, args);		if (options.hasOption("h"))		{			new HelpFormatter().printHelp("RamCompiler", cliOptions);			return;		}		Program root = null;				InputStream in = System.in;		if(options.hasOption('i'))			in = new FileInputStream(new File(options.getOptionValue('i')));				try		{						// Parser constructor must be invoked for side-effect			new frontend.generated.RamParser(in);			root = RamParser.Goal();		}		finally		{			if(in != System.in)				in.close();		}		// build symbol table		BuildSymbolTableVisitor symbolTableVisitor = new BuildSymbolTableVisitor();		root.accept(symbolTableVisitor); 		// perform type checking		TypeCheckVisitor typeChecker = new TypeCheckVisitor(symbolTableVisitor.getSymTab());		root.accept(typeChecker);		if (typeChecker.getErrorMsg().getHasErrors())		{			System.out.println("Error in front-end. Exiting.");			System.exit(1);		}		PrintStream ps = System.out;		if (options.hasOption('o'))			ps = new PrintStream(new java.io.FileOutputStream(					options.getOptionValue('o')));						IrGenerator irGenerator = new IrGenerator(symbolTableVisitor.getSymTab());		root.accept(irGenerator);						StringVisitor irTextVisitor = new StringVisitor(System.out);				for(RecordDeclaration recDec: irGenerator.getRecordList())		{			recDec.accept(irTextVisitor);		}		for(Function dec: irGenerator.getFrameList())		{			dec.accept(irTextVisitor);		}		IrVisitor codeGenerator = getVisitorForFormatString(options.getOptionValue('f'),				ps, irGenerator.getRecordList());				for(RecordDeclaration recDec: irGenerator.getRecordList())		{			recDec.accept(codeGenerator);		}		for(Function frameDec: irGenerator.getFrameList())		{			frameDec.accept(codeGenerator);		}				ps.close();					}}