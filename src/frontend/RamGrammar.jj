options {
  JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(RamParser)
  package frontend.generated;
  public class RamParser {}
PARSER_END(RamParser)


// Insert a specification of a lexical analysis here.
/* The regular expressions here will be skipped during lexical analysis. No
tokens are constructed from the productions that are defined here. */
SKIP : {

	"\n" | "\t" | " " | "\r"   
}


/* Insert the regular expressions for comments here. Special tokens do not
interact in the parsing process, but can be accessed from the parser. */
SPECIAL_TOKEN: {
	< COMMENT: "/*" ((~["*"])* "*" (~["/"]))* ((~["*"])* "*") "/"  > | < SHORT_COMMENT: "//" (~["\n"])* "\n" >

}


/* For the regular expressions on the right, the token on the left 
will be returned */
TOKEN : {	
	< CLASS : "class" >
	| < PUBLIC : "public" >	
	| < STATIC : "static" >
	| < VOID : "void" >
	| < MAIN : "main" >
	| < STRING : "String" >
	| < RETURN : "return" >
	| < INT : "int" >
	| < BOOL : "bool" >		
	| < IF : "if" >
	| < ELSE : "else" >
	| < WHILE : "while" >
	| < FOREACH : "foreach" >
	| < EXCLAMATION : ";" >
	| < PRINT : "print" >
	| < PRINTLN : "println" >
	| < LSQPAREN : "[" >
	| < RSQPAREN : "]" >
	| < DOT : "." >
	| < LENGTH : "length" >
	| < TRUE : "true" >
	| < FALSE : "false" >
	| < THIS : "this" >
	| < NEW : "new" >
	| < LBRACE : "{" >
	| < RBRACE : "}" >	  
	| < LPAREN : "(" >
	| < RPAREN : ")" >
	| < SEMICOLON : "!" >	
	| < AND : "and" >
	| < OR : "or" >
	| < LESSTHAN: "lt" >
	| < LESSTHANEQUALS: "lte" >	
	| < PLUS: "+">
	| < PLUSEQUALS: "+=" >
	| < MINUS: "-" >
	| < TIMES: "*" >
	| < COMMA: "," >
	| < EQUAL: "=" >
	| < EQUALITY : "==" >	
	| < ASSIGN: ":=" >
	| < COLON: ":" > 
	| < #DIGIT : ["0"-"9"] > 
	| < #LETTER : ["a"-"z", "A"-"Z"] >	
	| < IDENTIFIER : (< LETTER >)(< LETTER > | < DIGIT > | "_")* >
	| < INTEGER_LITERAL : ((< MINUS >)?< DIGIT >)+ >  
}



void Goal() :
{}
{  
  /* ( RamToken() )*  <EOF> */
  Program() <EOF>
}

void RamToken():
{}
{
  <CLASS>  |  <IDENTIFIER> | <LBRACE> | <PUBLIC> | 
  <STATIC> | <VOID> | <MAIN> | <LPAREN> | 
  <STRING> | <LSQPAREN> | <RSQPAREN> | <RPAREN> | 
  <RBRACE> | <PLUSEQUALS> | <SEMICOLON> | <RETURN> | 
  <COMMA> | <INT> | <BOOL> | <ASSIGN> |
  <IF> | <ELSE> | <WHILE> | <FOREACH> | <COLON> | 
  <PRINT> | <PRINTLN> | <AND> | <OR> | <LESSTHAN> | 
  <LESSTHANEQUALS> | <EQUALITY> | <PLUS> | <MINUS> | 
  <TIMES> | <DOT> | <LENGTH> | <INTEGER_LITERAL> | 
  <TRUE> | <FALSE> | <THIS> | <NEW> | <EXCLAMATION>
}

void Program() :
{}
{
  MainClass() ( ClassDecl() )*
}

void MainClass() :
{}
{
   <CLASS> <IDENTIFIER> <LBRACE> <PUBLIC> <STATIC> 
  <VOID> <MAIN> <LPAREN> <STRING> <LSQPAREN> 
  <RSQPAREN> <IDENTIFIER> <RPAREN> <LBRACE>  Statement() 
  <RBRACE> <RBRACE>
}

void Statement() :
{}
{
  (< LBRACE > (Statement())* < RBRACE >)
| < IF > <LPAREN > Exp() <RPAREN > Statement() < ELSE > Statement()
| < WHILE > <LPAREN > Exp() < RPAREN > Statement()
| < FOREACH > <LPAREN > Type() < COLON >< IDENTIFIER >< RPAREN > Statement()
| < PRINT ><LPAREN > ExpList() < RPAREN >< SEMICOLON >
| < PRINTLN ><LPAREN > ExpList() < RPAREN >< SEMICOLON >
| LOOKAHEAD(2) < IDENTIFIER >< EQUAL > Exp() < SEMICOLON >
| LOOKAHEAD(2) < IDENTIFIER >< PLUSEQUALS > Exp() < SEMICOLON >
| LOOKAHEAD(2) < IDENTIFIER ><LSQPAREN > Exp() < RSQPAREN > < EQUAL > Exp() < SEMICOLON > 
}

void ClassDecl() :
{}
{
	<CLASS> <IDENTIFIER>
	<LBRACE> (VarDecl())* (MethodDecl())* <RBRACE>
}

void Type() :
{}
{
LOOKAHEAD(2) < INT > <LSQPAREN > <RSQPAREN > 
| < BOOL >
| LOOKAHEAD(2) <INT >
| < IDENTIFIER >     	
}
void VarDecl() :
{}
{
  Type() <IDENTIFIER > <SEMICOLON >    
}

void FormalList() :
{}
{	[Type() < IDENTIFIER > (FormalRest())*]
}

void FormalRest() :
{}
{
  < COMMA > Type() < IDENTIFIER >}

void MethodDecl() :
{}
{
  < PUBLIC > Type() < IDENTIFIER > <LPAREN > FormalList() < RPAREN >
  < LBRACE > ( LOOKAHEAD(2) VarDecl())* (Statement())* < RETURN > Exp() < SEMICOLON > < RBRACE >     
}

void Exp() :
{}
{
	< INTEGER_LITERAL > ExpPrime()
	| < TRUE > ExpPrime()
	| < FALSE > ExpPrime()
	| < IDENTIFIER > ExpPrime()
	| < THIS > ExpPrime()
	| LOOKAHEAD(2) < NEW > < INT > <LSQPAREN > Exp() < RSQPAREN > ExpPrime()
	| LOOKAHEAD(2) < NEW > < IDENTIFIER > < LPAREN > < RPAREN > ExpPrime()
	| < EXCLAMATION > Exp() ExpPrime()
	| < LPAREN > Exp() <RPAREN > ExpPrime()	
}

void ExpList() :
{}
{
  [Exp() (ExpRest())*]}
  
void ExpRest() :
{}
{
  < COMMA > Exp()}
  


void ExpPrime() :
{}
{    [ Op() Exp() ExpPrime()
  | < LSQPAREN > Exp() < RSQPAREN > ExpPrime()
  | LOOKAHEAD(2) < DOT > < LENGTH > ExpPrime()  
  | LOOKAHEAD(2) < DOT > < IDENTIFIER > <LPAREN > ExpList() < RPAREN > ExpPrime()]
}

void Op() :
{}
{
  < AND >
| < OR >
| < LESSTHAN >
| < LESSTHANEQUALS >
| < PLUS >
| < MINUS >
| < TIMES >
}